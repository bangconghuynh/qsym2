use std::error::Error;
use std::fmt;

use itertools::Itertools;
use ndarray::{s, Array, Array2, Ix0, Ix2, Dimension};
use ndarray_einsum_beta::*;
use ndarray_linalg::{solve::Inverse, types::Lapack};
use num_complex::ComplexFloat;
use num_traits::ToPrimitive;

use crate::chartab::chartab_group::CharacterProperties;
use crate::chartab::{DecompositionError, SubspaceDecomposable};
use crate::group::{class::ClassProperties, GroupProperties};

// =======
// Overlap
// =======

// ----------------
// Trait definition
// ----------------

/// A trait for computing the inner product
/// $`\langle \hat{\iota} \mathbf{v}_i, \mathbf{v}_j \rangle`$ between two linear-space quantities
/// $`\mathbf{v}_i`$ and $`\mathbf{v}_j`$. The involutory operator $`\hat{\iota}`$ determines
/// whether the inner product is a sesquilinear form or a bilinear form.
pub trait Overlap<T, D>
where
    T: ComplexFloat + fmt::Debug + Lapack,
    D: Dimension
{
    /// If `true`, the inner product is bilinear and $`\hat{\iota} = \hat{\kappa}`$. If `false`,
    /// the inner product is sesquilinear and $`\hat{\iota} = \mathrm{id}`$.
    fn complex_symmetric(&self) -> bool;

    /// Returns the overlap between `self` and `other`, with respect to a metric `metric` of the
    /// underlying basis in which `self` and `other` are expressed.
    fn overlap(&self, other: &Self, metric: Option<&Array<T, D>>) -> Result<T, RepAnalysisError>;
}

// =====
// Orbit
// =====

// --------------------------------------
// Struct definitions and implementations
// --------------------------------------

/// A lazy iterator for orbits generated by the action of a group on an origin.
pub struct OrbitIterator<'a, G, I>
where
    G: GroupProperties,
{
    /// A mutable iterator over the elements of the group. Each element will be applied on the
    /// origin to yield a corresponding item in the orbit.
    group_iter: <<G as GroupProperties>::ElementCollection as IntoIterator>::IntoIter,

    /// The origin of the orbit.
    origin: &'a I,

    /// A function defining the action of each group element on the origin.
    action: fn(&G::GroupElement, &I) -> I,
}

impl<'a, G, I> OrbitIterator<'a, G, I>
where
    G: GroupProperties,
{
    /// Creates and returns a new orbit iterator.
    ///
    /// # Arguments
    ///
    /// * `group` - A group.
    /// * `origin` - An origin.
    /// * `action` - A function or closure defining the action of each group element on the origin.
    ///
    /// # Returns
    ///
    /// An orbit iterator.
    pub fn new(group: &G, origin: &'a I, action: fn(&G::GroupElement, &I) -> I) -> Self {
        Self {
            group_iter: group.elements().clone().into_iter(),
            origin,
            action
        }
    }
}

impl<'a, G, I> Iterator for OrbitIterator<'a, G, I>
where
    G: GroupProperties,
{
    type Item = I;

    fn next(&mut self) -> Option<Self::Item> {
        self.group_iter
            .next()
            .map(|op| (self.action)(&op, self.origin))
    }
}

// ----------------
// Trait definition
// ----------------

/// A trait for orbits arising from group actions.
pub trait Orbit<G, I>
where
    G: GroupProperties,
{
    /// Type of the iterator over items in the orbit.
    type OrbitIter: Iterator<Item = I>;

    /// The group generating the orbit.
    fn group(&self) -> &G;

    /// The origin of the orbit.
    fn origin(&self) -> &I;

    /// An iterator over items in the orbit arising from the action of the group on the origin.
    fn iter(&self) -> Self::OrbitIter;
}

// ========
// Analysis
// ========

// --------------------------------------
// Struct definitions and implementations
// --------------------------------------

#[derive(Debug, Clone)]
pub struct RepAnalysisError(pub String);

impl fmt::Display for RepAnalysisError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Representation analysis error: {}.", self.0)
    }
}

impl Error for RepAnalysisError {}

// ----------------
// Trait definition
// ----------------

/// A trait for representation or corepresentation analysis on an orbit of items spanning a
/// linear space.
pub(crate) trait RepAnalysis<G, I, T, D>: Orbit<G, I>
where
    T: ComplexFloat + Lapack + fmt::Debug,
    <T as ComplexFloat>::Real: ToPrimitive,
    G: GroupProperties + ClassProperties + CharacterProperties,
    G::GroupElement: fmt::Display,
    G::CharTab: SubspaceDecomposable<T>,
    D: Dimension,
    I: Overlap<T, D> + Clone,
    Self::OrbitIter: Iterator<Item = I>,
{
    // ----------------
    // Required methods
    // ----------------

    /// Sets the overlap matrix between the items in the orbit.
    ///
    /// # Arguments
    ///
    /// * `smat` - The overlap matrix between the items in the orbit.
    fn set_smat(&mut self, smat: Array2<T>);

    /// Returns the overlap matrix between the items in the orbit.
    #[must_use]
    fn smat(&self) -> &Array2<T>;

    /// Returns the transformation matrix $`\mathbf{X}`$ for the overlap matrix $`\mathbf{S}`$
    /// between the items in the orbit.
    ///
    /// The matrix $`\mathbf{X}`$ serves to bring $`\mathbf{S}`$ to full rank, *i.e.*, the matrix
    /// $`\tilde{\mathbf{S}}`$ defined by
    ///
    /// ```math
    ///     \tilde{\mathbf{S}} = \mathbf{X}^{\dagger\lozenge} \mathbf{S} \mathbf{X}
    /// ```
    ///
    /// is a full-rank matrix.
    ///
    /// If the overlap between items is complex-symmetric (see Overlap::complex_symmetric), then
    /// $`\lozenge = *`$ is the complex-conjugation operation, otherwise, $`\lozenge`$ is the
    /// identity.
    ///
    /// Depending on how $`\mathbf{X}`$ has been computed, $`\tilde{\mathbf{S}}`$ might also be
    /// orthogonal. Either way, $`\tilde{\mathbf{S}}`$ is always guaranteed to be of full-rank.
    #[must_use]
    fn xmat(&self) -> &Array2<T>;

    /// Returns the norm-preserving scalar map $`f`$ for every element of the generating group
    /// defined by
    ///
    /// ```math
    ///     \langle \hat{iota} \mathbf{v}_w, \hat{g}_i \mathbf{v}_x \rangle
    ///     = f \left( \langle \hat{iota} \hat{g_i^{-1}} \mathbf{v}_w, \mathbf{v}_x \rangle \right).
    /// ```
    ///
    /// Typically, if $`\hat{g}_i`$ is unitary, then $`f`$ is the identity, and if $`\hat{g}_i`$ is
    /// antiunitary, then $`f`$ is the complex-conjugation operation. Either way, the norm of the
    /// inner product is preserved.
    #[must_use]
    fn norm_preserving_scalar_map(&self, i: usize) -> fn(T) -> T;

    /// Returns the threshold for integrality checks of irreducible representation or
    /// corepresentation multiplicities.
    #[must_use]
    fn integrality_threshold(&self) -> <T as ComplexFloat>::Real;

    // ----------------
    // Provided methods
    // ----------------

    /// Calculates and stores the overlap matrix between items in the orbit, with respect to a
    /// metric of the basis in which these items are expressed.
    ///
    /// # Arguments
    ///
    /// * `metric` - The metric of the basis in which the orbit items are expressed.
    fn calc_smat(&mut self, metric: Option<&Array<T, D>>) -> &mut Self {
        let order = self.group().order();
        let mut smat = Array2::<T>::zeros((order, order));
        self.iter()
            .enumerate()
            .combinations_with_replacement(2)
            .for_each(|pair| {
                let (w, item_w) = &pair[0];
                let (x, item_x) = &pair[1];
                smat[(*w, *x)] = item_w.overlap(&item_x, metric).unwrap_or_else(|err| {
                    log::error!("{err}");
                    panic!("Unable to calculate the overlap between items `{w}` and `{x}` in the orbit.");
                });
                if *w != *x {
                    smat[(*x, *w)] = item_x.overlap(&item_w, metric).unwrap_or_else(|err| {
                        log::error!("{err}");
                        panic!(
                            "Unable to calculate the overlap between items `{x}` and `{w}` in the orbit."
                        );
                    });
                }
            });
        self.set_smat(smat);
        self
    }

    /// Computes the $`\mathbf{T}(g)`$ matrix for a particular element $`g`$ of the generating
    /// group.
    ///
    /// The elements of this matrix are given by
    ///
    /// ```math
    ///     T_{wx}(g)
    ///         = \langle \hat{\iota} \hat{g}_w \mathbf{v}_0, \hat{g} \hat{g}_x \mathbf{v}_0 \rangle.
    /// ```
    ///
    /// # Arguments
    ///
    /// * `op` - The element $`g`$ in the generating group.
    ///
    /// # Returns
    ///
    /// The matrix $`\mathbf{T}(g)`$.
    #[must_use]
    fn calc_tmat(&self, op: &G::GroupElement) -> Array2<T> {
        let ctb = self
            .group()
            .cayley_table()
            .expect("The Cayley table for the group cannot be found.");
        let i = self.group().get_index_of(op).unwrap_or_else(|| {
            panic!("Unable to retrieve the index of element `{op}` in the group.")
        });
        let order = self.group().order();
        let mut twx = Array2::<T>::zeros((order, order));
        for x in 0..order {
            let ix = ctb[(i, x)];
            let ixinv = ctb
                .slice(s![.., ix])
                .iter()
                .position(|&z| z == 0)
                .unwrap_or_else(|| panic!("The inverse of element index `{ix}` cannot be found."));

            for w in 0..order {
                let ixinv_w = ctb[(ixinv, w)];
                twx[(w, x)] = self.norm_preserving_scalar_map(ixinv)(self.smat()[(ixinv_w, 0)]);
            }
        }
        twx
    }

    /// Computes the representation or corepresentation matrix $`\mathbf{D}(g)`$ for a particular
    /// element $`g`$ in the generating group in the basis of the orbit.
    ///
    /// The matrix $`\mathbf{D}(g)`$ is defined by
    ///
    /// ```math
    ///     \hat{g} \mathcal{G} \cdot \mathbf{v}_0 = \mathcal{G} \cdot \mathbf{v}_0 \mathbf{D}(g),
    /// ```
    ///
    /// where $`\mathcal{G} \cdot \mathbf{v}_0`$ is the orbit generated by the action of the group
    /// $`\mathcal{G}`$ on the origin $`\mathbf{v}_0`$.
    ///
    /// # Arguments
    ///
    /// * `op` - The element $`g`$ of the generating group.
    ///
    /// # Returns
    ///
    /// The matrix $`\mathbf{D}(g)`$.
    #[must_use]
    fn calc_dmat(&self, op: &G::GroupElement) -> Array2<T> {
        let complex_symmetric = self.origin().complex_symmetric();
        let xmath = if complex_symmetric {
            self.xmat().t().to_owned()
        } else {
            self.xmat().t().mapv(|x| x.conj())
        };
        let smattilde = xmath.dot(self.smat()).dot(self.xmat());
        let smattilde_inv = smattilde
            .inv()
            .expect("The inverse of S~ could not be found.");
        let dmat = einsum(
            "ij,jk,kl,lm->im",
            &[&smattilde_inv, &xmath, &self.calc_tmat(op), self.xmat()],
        )
        .expect("Unable to compute the matrix product [(S~)^(-1) X† T X].")
        .into_dimensionality::<Ix2>()
        .expect("Unable to convert the matrix product [(S~)^(-1) X† T X] to two dimensions.");
        dmat
    }

    /// Computes the character of a particular element $`g`$ in the generating group in the basis
    /// of the orbit.
    ///
    /// See [`Self::calc_dmat`] for more information.
    ///
    /// # Arguments
    ///
    /// * `op` - The element $`g`$ of the generating group.
    ///
    /// # Returns
    ///
    /// The character $`\chi(g)`$.
    #[must_use]
    fn calc_character(&self, op: &G::GroupElement) -> T {
        let complex_symmetric = self.origin().complex_symmetric();
        let xmath = if complex_symmetric {
            self.xmat().t().to_owned()
        } else {
            self.xmat().t().mapv(|x| x.conj())
        };
        let smattilde = xmath.dot(self.smat()).dot(self.xmat());
        let smattilde_inv = smattilde
            .inv()
            .expect("The inverse of S~ could not be found.");
        let chi = einsum(
            "ij,jk,kl,li",
            &[&smattilde_inv, &xmath, &self.calc_tmat(op), self.xmat()],
        )
        .expect("Unable to compute the trace of the matrix product [(S~)^(-1) X† T X].")
        .into_dimensionality::<Ix0>()
        .expect("Unable to convert the trace of the matrix product [(S~)^(-1) X† T X] to zero dimensions.");
        *chi.iter()
            .next()
            .expect("Unable to extract the character from the representation matrix.")
    }

    /// Computes the characters of the elements in a conjugacy-class transversal of the generating
    /// group in the basis of the orbit.
    ///
    /// See [`Self::calc_dmat`]  and [`Self::calc_character`] for more information.
    ///
    /// # Returns
    ///
    /// The conjugacy class symbols and the corresponding characters.
    #[must_use]
    fn calc_characters(&self) -> Vec<(<G as ClassProperties>::ClassSymbol, T)> {
        let complex_symmetric = self.origin().complex_symmetric();
        let xmath = if complex_symmetric {
            self.xmat().t().to_owned()
        } else {
            self.xmat().t().mapv(|x| x.conj())
        };
        let smattilde = xmath.dot(self.smat()).dot(self.xmat());
        let smattilde_inv = smattilde
            .inv()
            .expect("The inverse of S~ could not be found.");
        let chis = (0..self.group().class_number()).map(|cc_i| {
            let cc = self.group().get_cc_symbol_of_index(cc_i).unwrap();
            let op = self.group().get_cc_transversal(cc_i).unwrap();
            let chi = einsum(
                "ij,jk,kl,li",
                &[&smattilde_inv, &xmath, &self.calc_tmat(&op), self.xmat()],
            )
            .expect("Unable to compute the trace of the matrix product (S~)^(-1) X† T X.")
            .into_dimensionality::<Ix0>()
            .expect("Unable to convert the trace of the matrix product (S~)^(-1) X† T X to zero dimensions.");
            (cc, *chi
                .iter()
                .next()
                .expect("Unable to extract the character from the representation matrix."))
        }).collect::<Vec<_>>();
        chis
    }

    /// Reduces the representation or corepresentation spanned by the items in the orbit to a
    /// direct sum of the irreducible representations or corepresentations of the generating group.
    ///
    /// # Returns
    ///
    /// The decomposed result.
    ///
    /// # Errors
    ///
    /// Errors if the decomposition fails, *e.g.* because one or more calculated multiplicities
    /// are non-integral.
    #[must_use]
    fn analyse_rep(
        &self,
    ) -> Result<
        <<G as CharacterProperties>::CharTab as SubspaceDecomposable<T>>::Decomposition,
        DecompositionError,
    > {
        let chis = self.calc_characters();
        let res = self.group().character_table().reduce_characters(
            &chis.iter().map(|(cc, chi)| (cc, *chi)).collect::<Vec<_>>(),
            self.integrality_threshold(),
        );
        res
    }
}
